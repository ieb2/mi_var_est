---
title: "main_doc"
author: "Ihsan E. Buker"
date: "`r Sys.Date()`"
output: html_document
---
# Dependencies 
```{r}
library(tidyverse)
library(magrittr)
library(mice)
library(MASS)

library(boot)
library(rsample) # rsample might give more flexibility with mids. 
```

# Toy Example 
```{r, cache=T}
set.seed(971423)

cor_mat <- matrix(c(1, 0.5, 0.5, 
                    0.5, 1, 0.5, 
                    0.5, 0.5, 1), nrow = 3, ncol = 3)

mean_vec <- c(1, 5, 10)

data_complete <- mvrnorm(100, mu = mean_vec, Sigma = cor_mat)

data_w_missing <- ampute(data_complete, prop = 0.3, mech = "MAR", patterns = c(0, 1, 1))$amp

# V1 is an outcome variable with 30% MAR. Covariates are fully observed. 

# The analysis model is V1 ~ V2 + V3 + epsilon 
# We are interested in estimating var(beta*V2)

# Congenial imputation model 
congenial_imputation_model <- make.predictorMatrix(data_w_missing) %>%
  as.matrix()

# Uncongenial imputation model 
uncongenial_imputation_model <- make.predictorMatrix(data_w_missing) %>%
  as.matrix()

uncongenial_imputation_model[1, ] <- c(0,1,0)

# Congenial imputation 
con_imp <- mice(data_w_missing, method = "pmm", predictorMatrix = congenial_imputation_model)

# Uncongenial imputation 
uncon_imp <- mice(data_w_missing, method = "pmm", predictorMatrix = uncongenial_imputation_model)

# Fitting analysis model 

# Rubin's rules 
# var(beta*V2) = 0.02020468 -> Our reference value. 
con_model <- with(con_imp, lm(V1 ~ V2 + V3)) %>%
  pool() %>%
  summary() %>%
  mutate(variance = std.error^2)

# var(beta*V2) = 0.01320681
uncon_model <- with(uncon_imp, lm(V1 ~ V2 + V3)) %>%
  pool() %>%
  summary() %>%
  mutate(variance = std.error^2)

# MI boot Rubin 
# Toy example, need for loop to incorporate the other m datasets. 
# map could also be an alternative
bootstrap_samples <-
  bootstraps(as.data.frame(complete(uncon_imp, "all")$"1"),
             times = 1E4,
             apparent = TRUE) %>%
  mutate(model = map(splits, ~ lm(V1 ~ V2 + V3,
                                  data = .)),
         coef_inf = map(model, tidy))


model_coefs <- bootstrap_samples %>%
  unnest(coef_inf) %>%
  filter(term == "V2") %>%
  mutate(variance = std.error^2)

model_coefs %>%
  ggplot(aes(x = variance, )) +
  geom_density(alpha = .7) +
  stat_function(fun = dnorm,
                args = list(mean = mean(model_coefs$variance),
                            sd = sd(model_coefs$variance)),
                col = "#1b98e0",
                size = 2) + 
  ggtitle("Distribution of Estimated Variance of B_{V2}") +
  xlab("Estimate") +
  ylab("Frequency") +
  theme_minimal()


```

# Current Questions 

  * Authors compare all methods to the $var(\beta_{V2})$ estimated by the congenial imputation model and Rubin's rules for variance. Since data is simulated, could we not compare all methods to the $var(\beta_{V2})$ obtained by fitting the analysis model to the complete dataset (prior to amputation). 